Grammar:

Rule 0     S' -> prog
Rule 1     prog -> listeInstructions
Rule 2     listeInstructions -> instruction listeInstructions
Rule 3     listeInstructions -> instruction
Rule 4     instruction -> IDENTIFIANT = expr ;
Rule 5     instruction -> ecrire
Rule 6     ecrire -> ECRIRE ( expr ) ;
Rule 7     fact -> variable
Rule 8     fact -> ENTIER
Rule 9     fact -> ( expr )
Rule 10    produit -> LIRE
Rule 11    produit -> produit % fact
Rule 12    produit -> produit / fact
Rule 13    produit -> produit * fact
Rule 14    produit -> - fact
Rule 15    produit -> fact
Rule 16    expr -> booleen
Rule 17    expr -> expr - produit
Rule 18    expr -> expr + produit
Rule 19    booleen -> variable
Rule 20    booleen -> FAUX
Rule 21    booleen -> VRAI
Rule 22    booleen -> produit
Rule 23    variable -> IDENTIFIANT

Unused terminals:

    INFERIEUR_OU_EGAL

Terminals, with rules where they appear:

%                    : 11
(                    : 6 9
)                    : 6 9
*                    : 13
+                    : 18
-                    : 14 17
/                    : 12
;                    : 4 6
=                    : 4
ECRIRE               : 6
ENTIER               : 8
FAUX                 : 20
IDENTIFIANT          : 4 23
INFERIEUR_OU_EGAL    : 
LIRE                 : 10
VRAI                 : 21
error                : 

Nonterminals, with rules where they appear:

booleen              : 16
ecrire               : 5
expr                 : 4 6 9 17 18
fact                 : 11 12 13 14 15
instruction          : 2 3
listeInstructions    : 1 2
produit              : 11 12 13 17 18 22
prog                 : 0
variable             : 7 19


state 0

    (0) S' -> . prog
    (1) prog -> . listeInstructions
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . IDENTIFIANT = expr ;
    (5) instruction -> . ecrire
    (6) ecrire -> . ECRIRE ( expr ) ;
    IDENTIFIANT     shift and go to state 4
    ECRIRE          shift and go to state 6

    prog                           shift and go to state 1
    listeInstructions              shift and go to state 2
    instruction                    shift and go to state 3
    ecrire                         shift and go to state 5

state 1

    (0) S' -> prog .


state 2

    (1) prog -> listeInstructions .
    $end            reduce using rule 1 (prog -> listeInstructions .)


state 3

    (2) listeInstructions -> instruction . listeInstructions
    (3) listeInstructions -> instruction .
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . IDENTIFIANT = expr ;
    (5) instruction -> . ecrire
    (6) ecrire -> . ECRIRE ( expr ) ;
    $end            reduce using rule 3 (listeInstructions -> instruction .)
    IDENTIFIANT     shift and go to state 4
    ECRIRE          shift and go to state 6

    instruction                    shift and go to state 3
    listeInstructions              shift and go to state 7
    ecrire                         shift and go to state 5

state 4

    (4) instruction -> IDENTIFIANT . = expr ;
    =               shift and go to state 8


state 5

    (5) instruction -> ecrire .
    IDENTIFIANT     reduce using rule 5 (instruction -> ecrire .)
    ECRIRE          reduce using rule 5 (instruction -> ecrire .)
    $end            reduce using rule 5 (instruction -> ecrire .)


state 6

    (6) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 9


state 7

    (2) listeInstructions -> instruction listeInstructions .
    $end            reduce using rule 2 (listeInstructions -> instruction listeInstructions .)


state 8

    (4) instruction -> IDENTIFIANT = . expr ;
    (16) expr -> . booleen
    (17) expr -> . expr - produit
    (18) expr -> . expr + produit
    (19) booleen -> . variable
    (20) booleen -> . FAUX
    (21) booleen -> . VRAI
    (22) booleen -> . produit
    (23) variable -> . IDENTIFIANT
    (10) produit -> . LIRE
    (11) produit -> . produit % fact
    (12) produit -> . produit / fact
    (13) produit -> . produit * fact
    (14) produit -> . - fact
    (15) produit -> . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    FAUX            shift and go to state 16
    VRAI            shift and go to state 17
    IDENTIFIANT     shift and go to state 10
    LIRE            shift and go to state 18
    -               shift and go to state 13
    ENTIER          shift and go to state 20
    (               shift and go to state 21

    expr                           shift and go to state 11
    booleen                        shift and go to state 12
    produit                        shift and go to state 14
    variable                       shift and go to state 15
    fact                           shift and go to state 19

state 9

    (6) ecrire -> ECRIRE ( . expr ) ;
    (16) expr -> . booleen
    (17) expr -> . expr - produit
    (18) expr -> . expr + produit
    (19) booleen -> . variable
    (20) booleen -> . FAUX
    (21) booleen -> . VRAI
    (22) booleen -> . produit
    (23) variable -> . IDENTIFIANT
    (10) produit -> . LIRE
    (11) produit -> . produit % fact
    (12) produit -> . produit / fact
    (13) produit -> . produit * fact
    (14) produit -> . - fact
    (15) produit -> . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    FAUX            shift and go to state 16
    VRAI            shift and go to state 17
    IDENTIFIANT     shift and go to state 10
    LIRE            shift and go to state 18
    -               shift and go to state 13
    ENTIER          shift and go to state 20
    (               shift and go to state 21

    expr                           shift and go to state 22
    booleen                        shift and go to state 12
    produit                        shift and go to state 14
    variable                       shift and go to state 15
    fact                           shift and go to state 19

state 10

    (23) variable -> IDENTIFIANT .
    ;               reduce using rule 23 (variable -> IDENTIFIANT .)
    -               reduce using rule 23 (variable -> IDENTIFIANT .)
    +               reduce using rule 23 (variable -> IDENTIFIANT .)
    %               reduce using rule 23 (variable -> IDENTIFIANT .)
    /               reduce using rule 23 (variable -> IDENTIFIANT .)
    *               reduce using rule 23 (variable -> IDENTIFIANT .)
    )               reduce using rule 23 (variable -> IDENTIFIANT .)


state 11

    (4) instruction -> IDENTIFIANT = expr . ;
    (17) expr -> expr . - produit
    (18) expr -> expr . + produit
    ;               shift and go to state 23
    -               shift and go to state 24
    +               shift and go to state 25


state 12

    (16) expr -> booleen .
    ;               reduce using rule 16 (expr -> booleen .)
    -               reduce using rule 16 (expr -> booleen .)
    +               reduce using rule 16 (expr -> booleen .)
    )               reduce using rule 16 (expr -> booleen .)


state 13

    (14) produit -> - . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    (23) variable -> . IDENTIFIANT
    ENTIER          shift and go to state 20
    (               shift and go to state 21
    IDENTIFIANT     shift and go to state 10

    fact                           shift and go to state 26
    variable                       shift and go to state 27

state 14

    (22) booleen -> produit .
    (11) produit -> produit . % fact
    (12) produit -> produit . / fact
    (13) produit -> produit . * fact
    ;               reduce using rule 22 (booleen -> produit .)
    -               reduce using rule 22 (booleen -> produit .)
    +               reduce using rule 22 (booleen -> produit .)
    )               reduce using rule 22 (booleen -> produit .)
    %               shift and go to state 28
    /               shift and go to state 29
    *               shift and go to state 30


state 15

    (19) booleen -> variable .
    (7) fact -> variable .
  ! reduce/reduce conflict for ; resolved using rule 7 (fact -> variable .)
  ! reduce/reduce conflict for - resolved using rule 7 (fact -> variable .)
  ! reduce/reduce conflict for + resolved using rule 7 (fact -> variable .)
  ! reduce/reduce conflict for ) resolved using rule 7 (fact -> variable .)
    %               reduce using rule 7 (fact -> variable .)
    /               reduce using rule 7 (fact -> variable .)
    *               reduce using rule 7 (fact -> variable .)
    ;               reduce using rule 7 (fact -> variable .)
    -               reduce using rule 7 (fact -> variable .)
    +               reduce using rule 7 (fact -> variable .)
    )               reduce using rule 7 (fact -> variable .)


state 16

    (20) booleen -> FAUX .
    ;               reduce using rule 20 (booleen -> FAUX .)
    -               reduce using rule 20 (booleen -> FAUX .)
    +               reduce using rule 20 (booleen -> FAUX .)
    )               reduce using rule 20 (booleen -> FAUX .)


state 17

    (21) booleen -> VRAI .
    ;               reduce using rule 21 (booleen -> VRAI .)
    -               reduce using rule 21 (booleen -> VRAI .)
    +               reduce using rule 21 (booleen -> VRAI .)
    )               reduce using rule 21 (booleen -> VRAI .)


state 18

    (10) produit -> LIRE .
    %               reduce using rule 10 (produit -> LIRE .)
    /               reduce using rule 10 (produit -> LIRE .)
    *               reduce using rule 10 (produit -> LIRE .)
    ;               reduce using rule 10 (produit -> LIRE .)
    -               reduce using rule 10 (produit -> LIRE .)
    +               reduce using rule 10 (produit -> LIRE .)
    )               reduce using rule 10 (produit -> LIRE .)


state 19

    (15) produit -> fact .
    %               reduce using rule 15 (produit -> fact .)
    /               reduce using rule 15 (produit -> fact .)
    *               reduce using rule 15 (produit -> fact .)
    ;               reduce using rule 15 (produit -> fact .)
    -               reduce using rule 15 (produit -> fact .)
    +               reduce using rule 15 (produit -> fact .)
    )               reduce using rule 15 (produit -> fact .)


state 20

    (8) fact -> ENTIER .
    %               reduce using rule 8 (fact -> ENTIER .)
    /               reduce using rule 8 (fact -> ENTIER .)
    *               reduce using rule 8 (fact -> ENTIER .)
    ;               reduce using rule 8 (fact -> ENTIER .)
    -               reduce using rule 8 (fact -> ENTIER .)
    +               reduce using rule 8 (fact -> ENTIER .)
    )               reduce using rule 8 (fact -> ENTIER .)


state 21

    (9) fact -> ( . expr )
    (16) expr -> . booleen
    (17) expr -> . expr - produit
    (18) expr -> . expr + produit
    (19) booleen -> . variable
    (20) booleen -> . FAUX
    (21) booleen -> . VRAI
    (22) booleen -> . produit
    (23) variable -> . IDENTIFIANT
    (10) produit -> . LIRE
    (11) produit -> . produit % fact
    (12) produit -> . produit / fact
    (13) produit -> . produit * fact
    (14) produit -> . - fact
    (15) produit -> . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    FAUX            shift and go to state 16
    VRAI            shift and go to state 17
    IDENTIFIANT     shift and go to state 10
    LIRE            shift and go to state 18
    -               shift and go to state 13
    ENTIER          shift and go to state 20
    (               shift and go to state 21

    expr                           shift and go to state 31
    booleen                        shift and go to state 12
    produit                        shift and go to state 14
    variable                       shift and go to state 15
    fact                           shift and go to state 19

state 22

    (6) ecrire -> ECRIRE ( expr . ) ;
    (17) expr -> expr . - produit
    (18) expr -> expr . + produit
    )               shift and go to state 32
    -               shift and go to state 24
    +               shift and go to state 25


state 23

    (4) instruction -> IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 4 (instruction -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 4 (instruction -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 4 (instruction -> IDENTIFIANT = expr ; .)


state 24

    (17) expr -> expr - . produit
    (10) produit -> . LIRE
    (11) produit -> . produit % fact
    (12) produit -> . produit / fact
    (13) produit -> . produit * fact
    (14) produit -> . - fact
    (15) produit -> . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    (23) variable -> . IDENTIFIANT
    LIRE            shift and go to state 18
    -               shift and go to state 13
    ENTIER          shift and go to state 20
    (               shift and go to state 21
    IDENTIFIANT     shift and go to state 10

    produit                        shift and go to state 33
    fact                           shift and go to state 19
    variable                       shift and go to state 27

state 25

    (18) expr -> expr + . produit
    (10) produit -> . LIRE
    (11) produit -> . produit % fact
    (12) produit -> . produit / fact
    (13) produit -> . produit * fact
    (14) produit -> . - fact
    (15) produit -> . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    (23) variable -> . IDENTIFIANT
    LIRE            shift and go to state 18
    -               shift and go to state 13
    ENTIER          shift and go to state 20
    (               shift and go to state 21
    IDENTIFIANT     shift and go to state 10

    produit                        shift and go to state 34
    fact                           shift and go to state 19
    variable                       shift and go to state 27

state 26

    (14) produit -> - fact .
    %               reduce using rule 14 (produit -> - fact .)
    /               reduce using rule 14 (produit -> - fact .)
    *               reduce using rule 14 (produit -> - fact .)
    ;               reduce using rule 14 (produit -> - fact .)
    -               reduce using rule 14 (produit -> - fact .)
    +               reduce using rule 14 (produit -> - fact .)
    )               reduce using rule 14 (produit -> - fact .)


state 27

    (7) fact -> variable .
    %               reduce using rule 7 (fact -> variable .)
    /               reduce using rule 7 (fact -> variable .)
    *               reduce using rule 7 (fact -> variable .)
    ;               reduce using rule 7 (fact -> variable .)
    -               reduce using rule 7 (fact -> variable .)
    +               reduce using rule 7 (fact -> variable .)
    )               reduce using rule 7 (fact -> variable .)


state 28

    (11) produit -> produit % . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    (23) variable -> . IDENTIFIANT
    ENTIER          shift and go to state 20
    (               shift and go to state 21
    IDENTIFIANT     shift and go to state 10

    fact                           shift and go to state 35
    variable                       shift and go to state 27

state 29

    (12) produit -> produit / . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    (23) variable -> . IDENTIFIANT
    ENTIER          shift and go to state 20
    (               shift and go to state 21
    IDENTIFIANT     shift and go to state 10

    fact                           shift and go to state 36
    variable                       shift and go to state 27

state 30

    (13) produit -> produit * . fact
    (7) fact -> . variable
    (8) fact -> . ENTIER
    (9) fact -> . ( expr )
    (23) variable -> . IDENTIFIANT
    ENTIER          shift and go to state 20
    (               shift and go to state 21
    IDENTIFIANT     shift and go to state 10

    fact                           shift and go to state 37
    variable                       shift and go to state 27

state 31

    (9) fact -> ( expr . )
    (17) expr -> expr . - produit
    (18) expr -> expr . + produit
    )               shift and go to state 38
    -               shift and go to state 24
    +               shift and go to state 25


state 32

    (6) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 39


state 33

    (17) expr -> expr - produit .
    (11) produit -> produit . % fact
    (12) produit -> produit . / fact
    (13) produit -> produit . * fact
    ;               reduce using rule 17 (expr -> expr - produit .)
    -               reduce using rule 17 (expr -> expr - produit .)
    +               reduce using rule 17 (expr -> expr - produit .)
    )               reduce using rule 17 (expr -> expr - produit .)
    %               shift and go to state 28
    /               shift and go to state 29
    *               shift and go to state 30


state 34

    (18) expr -> expr + produit .
    (11) produit -> produit . % fact
    (12) produit -> produit . / fact
    (13) produit -> produit . * fact
    ;               reduce using rule 18 (expr -> expr + produit .)
    -               reduce using rule 18 (expr -> expr + produit .)
    +               reduce using rule 18 (expr -> expr + produit .)
    )               reduce using rule 18 (expr -> expr + produit .)
    %               shift and go to state 28
    /               shift and go to state 29
    *               shift and go to state 30


state 35

    (11) produit -> produit % fact .
    %               reduce using rule 11 (produit -> produit % fact .)
    /               reduce using rule 11 (produit -> produit % fact .)
    *               reduce using rule 11 (produit -> produit % fact .)
    ;               reduce using rule 11 (produit -> produit % fact .)
    -               reduce using rule 11 (produit -> produit % fact .)
    +               reduce using rule 11 (produit -> produit % fact .)
    )               reduce using rule 11 (produit -> produit % fact .)


state 36

    (12) produit -> produit / fact .
    %               reduce using rule 12 (produit -> produit / fact .)
    /               reduce using rule 12 (produit -> produit / fact .)
    *               reduce using rule 12 (produit -> produit / fact .)
    ;               reduce using rule 12 (produit -> produit / fact .)
    -               reduce using rule 12 (produit -> produit / fact .)
    +               reduce using rule 12 (produit -> produit / fact .)
    )               reduce using rule 12 (produit -> produit / fact .)


state 37

    (13) produit -> produit * fact .
    %               reduce using rule 13 (produit -> produit * fact .)
    /               reduce using rule 13 (produit -> produit * fact .)
    *               reduce using rule 13 (produit -> produit * fact .)
    ;               reduce using rule 13 (produit -> produit * fact .)
    -               reduce using rule 13 (produit -> produit * fact .)
    +               reduce using rule 13 (produit -> produit * fact .)
    )               reduce using rule 13 (produit -> produit * fact .)


state 38

    (9) fact -> ( expr ) .
    %               reduce using rule 9 (fact -> ( expr ) .)
    /               reduce using rule 9 (fact -> ( expr ) .)
    *               reduce using rule 9 (fact -> ( expr ) .)
    ;               reduce using rule 9 (fact -> ( expr ) .)
    -               reduce using rule 9 (fact -> ( expr ) .)
    +               reduce using rule 9 (fact -> ( expr ) .)
    )               reduce using rule 9 (fact -> ( expr ) .)


state 39

    (6) ecrire -> ECRIRE ( expr ) ; .
    IDENTIFIANT     reduce using rule 6 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 6 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 6 (ecrire -> ECRIRE ( expr ) ; .)


Conflicts:

reduce/reduce conflict in state 15 resolved using rule fact -> variable
rejected rule (booleen -> variable) in state 15
Rule (booleen -> variable) is never reduced